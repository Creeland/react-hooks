# Tic Tac Toe

A `username` is one thing, but a real UI is a bit different. Often you need more
than one element of state in your component, so you'll call `useState`
more than once. Please note that each call to `useState` in a given
component will give you a unique state and updater function. So this works:

```tsx
const [stateA, setStateA] = useState('a')
const [stateTwo, setStateTwo] = useState(2)
```

Another thing to learn about `useState` is the state updater function (like our
`setUsername` we've used before) can actually accept a function. For example:

```tsx
const [count, setCount] = useState(0)

// then in a click event handler or something:
setCount(count + 1)

// but this is the exact same thing:
setCount(previousCount => previousCount + 1)
```

Because there are two ways to do the same thing, it's nice to know why/when
you'd use one over the other. Here's the "rule":

**If your new value for state is calculated based on the previous value of
state, use the function form. Otherwise, either works fine.**

For a deeper dive on this, read
[useState lazy initialization and function updates](https://kentcdodds.com/blog/use-state-lazy-initialization-and-function-updates)
and check
[`examples/set-state-callback.tsx`](http://localhost:3000/isolated/examples/set-state-callback.tsx).

Some of our state updates rely on the current value of state so make sure you
avoid problems by using the function form.

This one's a bit tougher than some of the other exercises, so make sure you're
well hydrated and do a bit of stretching before starting this. Now might also be
a good time to make sure you have
[the React DevTools installed](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)
and use that while debugging.
